{"ast":null,"code":"//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./rng'); // Maps for number <-> hex string conversion\n\n\nvar _byteToHex = [];\nvar _hexToByte = {};\n\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n} // **`parse()` - Parse a UUID into it's component bytes**\n\n\nfunction parse(s, buf, offset) {\n  var i = buf && offset || 0,\n      ii = 0;\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {\n    if (ii < 16) {\n      // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  }); // Zero out remaining bytes if string was short\n\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n} // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n\n\nfunction unparse(buf, offset) {\n  var i = offset || 0,\n      bth = _byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];\n} // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n// random #'s we need to init node and clockseq\n\n\nvar _seedBytes = _rng(); // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n\n\nvar _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]]; // Per 4.2.2, randomize (14 bit) clockseq\n\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff; // Previous uuid creation time\n\n\nvar _lastMSecs = 0,\n    _lastNSecs = 0; // See https://github.com/broofa/node-uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n  options = options || {};\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  var node = options.node || _nodeId;\n\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n} // **`v4()` - Generate random UUID**\n// See https://github.com/broofa/node-uuid for API details\n\n\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n} // Export public API\n\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\nmodule.exports = uuid;","map":{"version":3,"sources":["/Users/victorfink/Documents/Projects/noteweb/node_modules/vis-react/node_modules/uuid/uuid.js"],"names":["_rng","require","_byteToHex","_hexToByte","i","toString","substr","parse","s","buf","offset","ii","toLowerCase","replace","oct","unparse","bth","_seedBytes","_nodeId","_clockseq","_lastMSecs","_lastNSecs","v1","options","b","clockseq","undefined","msecs","Date","getTime","nsecs","dt","Error","tl","tmh","node","n","v4","Array","rnds","random","rng","uuid","module","exports"],"mappings":"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","sourcesContent":["//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n"]},"metadata":{},"sourceType":"script"}